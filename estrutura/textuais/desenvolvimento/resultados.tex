% RESULTADOS-------------------------------------------------------------------
%Cada capítulo deve conter uma pequena introdução (tipicamente, um ou dois parágrafos) que deve deixar claro o objetivo e o que será discutido no capítulo, bem como a organização do capítulo.
%\chapter{ANÁLISE E DISCUSSÃO DOS RESULTADOS}
\chapter{RESULTADOS}
\label{Chap:Resultados}

Este capítulo apresenta o que foi obtido como resultado deste trabalho e as experiências do autor durante o desenvolvimento do sistema de atualização de \firmware\ over-the-air. Primeiro será apresentado os resultados mostrando como é um processo de atualização realizado com sucesso e em seguida discutido o uso e vantagens e desvantagens do sistema. 

\section{PROCESSO DE ATUALIZAÇÃO DE FIRMWARE}
Aqui é presentado todo o processo de atualização feito para comprovar o funcionamento do sistema desenvolvido neste trabalho, com isso é abordado desde a inicialização do \firmware\ 1 com sua mensagem de apresentação, a disponibilização do \firmware\ 2 no servidor, o processo de atualização, a inicialização do \firmware\ 2 na plataforma embarcada STM32F746G e sua mensagem de apresentação.

\subsection{ESTADO INICIAL DO MICROCONTROLADOR}
Inicialmente é gravado no microcontrolador o \bootloader\ e depois o \firmware\ 1, com isso temos a memória flash preenchida separadamente, visto que definimos áreas diferentes para aplicação e \bootloader\ no arquivo de linker, assim fica o estado inicial da memória do microcontrolador no inicio do teste.

Com o \bootloader\ e \firmware\ 1 gravados no \textit{hardware} já é possível fazer a primeira inicialização do sistema, com a reinicialização do hardware o sistema inicializa o \bootloader\ para poder dar sequencia de atualização ou salto para a aplicação. A \autoref{memoriaflash} mostra a configuração de memória flash do microcontrolador.

\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=0.9]{dados/figuras/flash_ocupation.png}
     \caption{Configuração da memória flash. \newline Fonte: Autoria própria.}
     \label{memoriaflash}
\end{figure}

\subsection{INICIALIZAÇÃO DO BOOTLOADER}
Após todos os processos de inicialização o \bootloader\ é executado. Como o intuito é que o \bootloader\ não ocupe muito espaço da memória flash do microcontrolador, e de forma que se adapte para todos os tipos de microcontroladores da familia STM32, não foi previsto nenhum tipo de sinalização durante sua operação. Dessa forma, a substituição do firmware e o salto para a aplicação são executadas sem nenhuma informação visual para o usuário.

Durante sua execução o \bootloader\ verifica a versão do \firmware\ atual e o compara com a versão que está no cartão SD, caso a versão atual for menor ou não seja encontra a nova versão do \firmware\, o \bootloader\ inicializa o \firmware\ que está na memória flash. Como neste caso de teste o cartão SD se encontra vazio, o \bootloader\ assume que não há nenhuma atualização a ser efetuada, assim ele inicializa a sequência de salto para a aplicação. 

\subsection{INICIALIZAÇÃO DO FIRMWARE 1}
Com a inicialização da aplicação efetuada pelo \bootloader, são executadas todas as inicializações de drivers, das bibliotecas utilizadas pelo \firmware\ 1, e assim inicializado o sistema operacional FreeRTOS, e exibida via UART a mensagem de confirmação de montagem do driver do cartão SD e a mensagem de apresentação contendo a versão do \textit{software} atual e o sua frase de identificação. A partir da impressão dessas frases o sistema operacional iniciará a tarefa OTA.

\subsection{OTA}
Ao iniciar a função OTA será buscado no servidor o arquivo contendo a versão do \firmware\ 2, com esse arquivo baixado ele fará a comparação com a versão atual do \firmware\ e caso necessário irá fazer o download do novo \firmware, e do arquivo contendo o hash deste \firmware. Tendo esses arquivos salvos no cartão SD ele irá fazer o hash do \firmware\ baixado e verificar assim a integridade do arquivo baixado. Caso todos os processos ocorram com sucesso ele irá fazer com que esses arquivos permaneçam no cartão SD e iniciará o processo de salto para o \bootloader, que encerra todos os driver e o sistema operacional e pula para a região do \bootloader\ para o executar. Todo esse processo pode ser visto na \autoref{Firmware1OTA}.

\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=0.9]{dados/figuras/Firmware1.png}
     \caption{Processo de atualização realizado pela função OTA no \textit{firmware} 1 \newline Fonte: Autoria própria.}
     \label{Firmware1OTA}
\end{figure}

\subsection{REINICIALIZAÇÃO DO SISTEMA PARA O BOOTLOADER}
O \bootloader\ é inicializado novamente, mas agora ele consegue achar um arquivo de versão escrito no cartão SD e com isso fazer a comparação com a versão de \firmware\ e como a versão encontrada no cartão SD é maior que a escrita na flash ele iniciará o processo de troca de \firmware.
Após a troca de \firmware\ ele escreverá nas 4 últimas posição da memória a versão do novo \firmware, fazendo com que atualização seja concluída com sucesso, assim podendo novamente fazer o processo de pulo para a aplicação.
\subsection{INICIALIZAÇÃO DO FIRMWARE 2}
Após o pulo para aplicação efetuada pelo \bootloader\ após a atualização são executadas todas as inicializações de drivers, das bibliotecas utilizadas pelo \firmware\ 2, e assim inicializado o sistema operacional, exibida a mensagem de confirmação de montagem do driver do cartão SD e a mensagem de apresentação contendo a versão do \textit{software} atual e o sua nova frase de identificação como pode ser observado na \autoref{fraseidentificacao2}. Assim concluindo com sucesso um processo de atualização de \firmware.

\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=0.9]{dados/figuras/Firmware2.png}
     \caption{\textit{Firmware} 2 iniciado com processo de atualização. \newline Fonte: Autoria própria.}
     \label{fraseidentificacao2}
\end{figure}

\section{TRATAMENTOS DE ERROS IMPLEMENTADOS}
Durante o processo de atualização e obtenção de arquivos diversos erros podem ocorrer, desde quedas de energia, a falhas de conexão com o servidor. Para evitar que esses erros deixem a plataforma embarcada em um estado não conhecido foram implementados diversos tratamentos de erros que serão explanados nessa sessão.
\subsection{FALHA AO ENCONTRAR ARQUIVOS NO SERVIDOR}
Caso o cliente OTA não conseguir encontrar no servidor um dos arquivos que são necessários para a atualização, como o arquivo contendo o número versão, ou o arquivo contendo a nova versão do \firmware, ou mesmo o arquivo com o hash desse \firmware. O cliente OTA tem a capacidade de detectar esse tipo de erro e apresentar ao usuário este erro, tornando fácil a identificação dessa falha. A \autoref{erro_404} apresenta como o cliente OTA informa o usuário do erro que ocorreu.
\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=1.2]{dados/figuras/404.png}
     \caption{Erro ao não encontrar arquivo no servidor. \newline Fonte: Autoria própria.}
     \label{erro_404}
\end{figure}

\subsection{FALHA AO COMPARAR HASH}
Após o download da última versão do \firmware, o cliente OTA gera um hash utilizando a função de hash sha-256 que a biblioteca MbedTLS fornece, esse hash é comparado com o que foi obtido do servidor para garantirmos que o \firmware\ obtido está integro e não corrompido. Caso essa comparação falhe uma mensagem é mostrada para o usuário, essa mensagem pode ser observada na \autoref{erro_hash}.
\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=1.2]{dados/figuras/hash_error.png}
     \caption{Erro ao comparar hash do servidor com a hash gerada a partir do \firmware\ obtido do servidor. \newline Fonte: Autoria própria.}
     \label{erro_hash}
\end{figure}
\subsection{QUEDA DE ENERGIA DURANTE PROCESSO DE ATUALIZAÇÃO}
Caso exista uma queda de energia, ou algo que faça com que o microcontrolador seja reiniciado durante o processo de escrita do firmware na flash, que ocorre no \bootloader, o sistema tem a capacidade de identificar este erro a partir do numero de versão que está presente no fim da memória. Caso esse valor seja igual a 0xFFFFFFFF, significa que a última operação de escrita da flash não foi concluída com sucesso, assim é necessário que ela seja refeita. Assim o \bootloader\ executa uma rotina de reinicialização do sistema caso não encontre o firmware para realizar a atualização no cartão SD, e caso encontre ele executa a atualização e salta para a nova aplicação.


\section{DISCUSSÃO}
Os resultado obtidos mostraram que o sistema de atualização de \textit{firmware Over-The-Air} proposto neste trabalho funciona, e que todo o processo desde a verificação de uma aplicação válida feita pelo \bootloader, seu processo de atualização e as obtenções e verificações de arquivos da API de atualização OTA ocorrem com sucesso.

Como o \bootloader\ ocupa 22 Kbytes de espaço na memória flash ele pode ser utilizado por diversas placas da familia de microcontroladores STM32 que possuam um setor da memória maior que esse espaço. Com a aplicação que foi utilizada para testar este trabalho que possui em seu código somente a API de atualização, as bibliotecas que são necessárias para esse trabalho e o sistema operacional FreeRTOS, ocupam juntos cerca de 294 Kbytes. Assim a aplicação do usuário ainda teria um espaço de 674 Kbytes restante na plataforma que utilizamos para teste se contarmos junto o espaço reservado para o \bootloader. 

As bibliotecas utilizadas acabam por ocupar quase todo esse espaço, pois analisando a compilação podemos identificar a quantidade de memória utilizada por cada uma delas. A biblioteca FatFS acaba por ocupar cerca de 8 Kbytes de memória, a LwIP en torno de 50 Kbytes de memória e por fim a MbedTLS que ocupa aproximadamente 135 Kbytes de memória, tornando ela biblioteca que mais ocupa espaço na flash. Temos então que aproximadamente 193 Kbytes do \firmware\ é ocupados pelas bibliotecas, assim dois terços do \firmware\ desenvolvido é ocupado pelo por funções e outras definições das bibliotecas. A API de atualização desenvolvida ocupa por volta de 2 Kbytes, ficando o restando do \firmware\ sendo ocupado pelo sistema operacional, outras funções do HAL e demais códigos de inicialização.

Todo essa quantidade de memória gasta poderia ser reduzida drásticamente caso não houvesse a necessidade de haver criptografia com o uso da biblioteca MbedTLS, poderia ser economizada 135 Kbytes de memória somente com essa modificação. Outra possibilidade que não foi abordada neste trabalho é a otimização da compilação com o objetivo de se diminuir a ocupação da memória, que poderia diminuir o tamanho total do código de 294 Kbytes para cerca de 260 Kbytes. Outra otimização que pode ser feita é a otimização com o intuito de se aumentar a performance, fazendo com que o código ocupe aproximadamente de 350 Kbytes.


Com essa informação sobre o tamanho dos arquivos, é possível notar que este sistema de atualização não é tão portável quanto se esperava no inicio deste trabalho, visto que só para ter um sistema de atualização funcional precisamos que o hardware em que se deseja ter esse sistema tenha ao menos 512 Kbytes de memória FLASH, diminuindo muito a quantidade de microcontroladores que poderiam utilizar este sistema. Esse sistema acaba sendo muito proveitoso para aplicações que já utilizam essas bibliotecas, pois assim não precisariam incluir novamente as bibliotecas FATFS, MbedTLS, LWIP.

Ainda assim é possível afirmar que o sistema cumpre com o objetivo geral e específicos propostos, visto que o sistema é capaz de efetuar a atualização da plataforma embarcada STM32F746NGH6 da forma proposta e ainda é capaz de identificar quando houve falhas em seu sistema de atualização e se recuperar de forma autónoma dessas falhas.
