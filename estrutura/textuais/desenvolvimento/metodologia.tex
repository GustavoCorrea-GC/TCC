% METODOLOGIA------------------------------------------------------------------

\chapter{SISTEMA OPEN-SOURCE PARA A ATUALIZAÇÃO DE FIRMWARE OVER-THE-AIR BASEADO NAS BIBLIOTECAS LWIP, MBED TLS E FATFS}
\label{chap:metodologia}
Neste capitulo é retratado como será o funcionamento do sistema que será desenvolvido, mostrada uma visão geral do projeto, listada as funcionalidades de cada uma das partes do \textit{software}, explicada sua atividade, sua implementação, e as ferramentas utilizadas para o seu teste e os materiais utilizados. 

\section{VISÃO GERAL}
O \textit{software} que será desenvolvido neste trabalho é dividido em duas partes, uma contendo o \bootloader, com o auxílio da biblioteca FatFs, que é um módulo genérico do sistema de arquivo FAT, realizará a comunicação com o cartão SD, que conterá o novo \firmware préviamente recebido. Assim poderá substituir o \software anterior da aplicação por um novo. Essa parte do \software ficará armazenada em uma região da memória que não poderá ser reescrita, então é uma peça do programa que não poderá ser substituída. Será uma parte que não é portável para todas as plataformas, ficando a cargo do projetista fazer o port para outras placas.

A outra parte deste trabalho será uma API, contendo as demais funções necessárias para a comunicação com o servidor, que enviará para o sistema o novo \firmware, por meio do uso da biblioteca LwIP, garantirá a segurança dessa conexão com a utilização de uma camada extra de proteção, com biblioteca Mbed TLS. Essa API irá conectar-se a um servidor em um intervalo de tempo determinado pelo projetista, em que verificará a disponibilidade de uma nova versão de \software. 

Após a confirmação de um novo \firmware ser confirmada, em um tempo determinado pelo projetista a API irá se comunicar novamente com o servido com o intuito de fazer o \download desta nova versão, e a armazenar em um endereço de memória predeterminado no cartão SD do sistema, para que então o \bootloader entre em ação após uma reinicialização do sistema.
A API será uma peça de \software que poderá ser substituída e atualizada em conjunto com as demais aplicações do sistema, como, as bibliotecas LwIP, Mbed TSL, o sistema operacional, entre outras peças de \software utilizadas pela aplicação. 

O sistema de atualização OTA utiliza-se de bibliotecas já conhecidas e vastamente utilizadas por desenvolvedores de sistemas embarcados, para que assim projetos que necessitem fazer comunicação segura via rede, leitura e escrita de cartões SD, possam utilizar esse sistema de modo a poupar espaço na memória, visando a reutilização dessas bibliotecas, portanto o sistema pode ser amplamente utilizado. Será utilizada o \textit{kit} de desenvolvimento STM32F7 \textit{Discovery}, onde será inicialmente desenvolvida a API e suas tarefas e o \textit{bootloader} que serão os principais componentes desse sistema.

Em caso de uma falha durante o processo de atualização OTA e o sistema não responda após a atualização, o sistema tem a habilidade de se recuperar. Como não haverá sobreescrita na área em que o \textit{firmware} esta posicionado no cartão SD, uma simples reinicialização do sistema pode fazer com que o bootloader seja ativado novamente e refaça o processo de cópia da memória.

O sistema de atualização irá funcionar da seguinte forma, após a inicialização do sistema o \bootloader entra em ação e verifica a existência de um novo \firmware, no caso negativo ele inicia normalmente o \software principal da aplicação. No caso positivo, o \bootloader inicia o processo de substituição de \textit{firmware}, após a troca, o novo \software é iniciado. Durante a execução da aplicação principal do sistema e em um tempo determinado pelo projetista a API entra em contato com o servidor para verificar a disponibilidade de um \software novo, em caso positivo ela agenda um período para a atualização do \firmware, no caso negativo ele continua a execução da aplicação. 

Caso haja uma atualização, quando o horário do agendamento chegar, a API irá conectar-se ao servidor e iniciar o processo de \download do firmware novo e armazena-lo em uma área já predefinida do cartão SD para que o \bootloader possa o encontrar. Após o \download o sistema irá ser reiniciado e o \bootloader entrará em ação novamente. 
%De forma resumida o funcionamento do sistema pode ser visto na \autoref{Funcionamento}, 


%Com a  As tarefas serão produzidas a partir de b
%sistema possa conter intersecções com trechos de codigos utilizados em varios projetos que necessitam

%Adicionar diagrama de blocos!!!!

% A seguir será explicado parcialmente como funcionarão as funções das tarefas, do \textit{bootloader}, e do servidor HTTP.
%Cada capítulo deve conter uma pequena introdução (tipicamente, um ou dois parágrafos) que deve deixar claro o objetivo e o que será discutido no capítulo, bem como a organização do capítulo.

\section{\textit{BOOTLOADER}}
\label{sec:Bootloader}

A partir de um arquivo de \textit{linker}, a memória da plataforma será customizada com o intuito de abrigar os arquivos necessários para o \bootloader e protege-lo de eventuais sobrescritas que podem vir a ocorrer. Esse arquivo de \textit{linker}, assim como o próprio \textit{bootloader}, será escrito somente para a plataforma STM32F7, visto que cada plataforma tem suas próprias características como, tamanho de memória e endereços diferentes para cada fabricante e/ou arquitetura.

No arquivo de \linker sera especificada uma área especial na memória Flash do sistema em que será abrigado o \bootloader e a biblioteca FatFs que fará parte do \bootloader. Também será responsável por fazer com que o \bootloader seja chamado após o \textit{C copy Down} no lugar da função \textit{main}. Assim podemos garantir que o \bootloader sempre entre em ação após a reinicialização do sistema embarcado.

%irá verificar o \textit{hash} da nova versão, verificando a integridade e origem do \textit{software},

O \textit{bootloader} será responsável em fazer a troca de cada versão de \textit{firmware} instalado no sistema embarcado. Sempre que o sistema for iniciado, o \textit{bootloader} será inicializado e fará a procura de um novo \textit{firmware} em um endereço de memória já predeterminado. Essa busca será possível pelo fato do \textit{middleware} FatFs, que esta implementada junto ao \bootloader, criar um sistema de arquivos no cartão SD do sistema alvo, assim o \bootloader pode acessar a memória do cartão sem a necessidade da aplicação final ser inicializada.

Se a procura retornar com um resultado positivo para a existência de uma nova versão de \software, o \bootloader inicia o processo de atualização. Nesse processo o \bootloader substitui completamente o \software e demais \textit{middlewares} e API's em áreas não protegidas na memória, pelo binário do \textit{firmware} presente no cartão SD. Esse processo será implementado com o uso da  função memcpy, já conhecida e utilizada por diversos desenvolvedores, com o intuito de se deixar o código do \bootloader mais reutilizável. O funcionamento resumido do \textit{bootloader} pode ser observado na \autoref{fig:DiagBootloader}.

\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=0.9]{dados/figuras/BootloaderDiag.png}
     \caption{Diagrama de funcionamento do \bootloader. \newline Fonte: autoria própria.}
     \label{fig:DiagBootloader}
\end{figure}
%Inserir seu texto aqui...

%\section{SERVIDOR HTTP}
%\label{sec:ServidorHTTP}

%A partir de um computador conectado à mesma rede que o sistema embarcado, haverá um servidor HTTP que ficará responsável por esperar requisições do dispositivo, para consultar a disponibilidade de uma versão atualizada do \textit{software}, e após a confirmação dessa nova versão, esse servidor irá enviar o \textit{firmware} para a plataforma embarcada.
%Inserir seu texto aqui...

\section{API DE ATUALIZAÇÃO OTA}
\label{sec:API}

A API de atualização OTA que será desenvolvida neste trabalho tem o proposito de ser o mais portável possível, para assim ser reutilizada por diversos projetos que necessitem da troca de seu \software. Com esse objetivo, serão utilizadas as bibliotecas já bem difundidas, a LwIP para a criação da pilha TCP/IP, a Mbed TLS para criar uma camada se segurança nesta pilha, e a FATFS para a criação de um sistema de arquivos FAT. Assim desenvolvedores podem se aproveitar do fato de que essas bibliotecas já estão em seus sistemas como padrão para utiliza-las em suas próprias funcionalidades. A \autoref{fig:DiagAPI} ilustra de forma resumida o funcionamento da API.

\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=0.9]{dados/figuras/DiagAPI.png}
     \caption{Diagrama de funcionamento da API.\newline Fonte: autoria própria.}
     \label{fig:DiagAPI}
\end{figure}

A seguir será retratado como serão cada uma das funcionalidades necessárias na API.

\subsection{COMUNICAÇÃO COM O SERVIDOR}

Com o uso da biblioteca LwIP e MbedTLS será criada uma pilha de comunicação no sistema alvo, que ficará responsável pela conexão segura com o servidor que fornecerá o novo firmware. Na implementação da pilha de comunicação utilizando a  biblioteca LwIP, será utilizada sua API Netconn, pois o intuito é deixar o sistema de atualização portável, e a API Netconn fornece suporte a sistemas operacionais de tempo real.

Como a biblioteca Mbed TLS já foi desenvolvida para ser integrada facilmente a várias aplicações embarcadas, ela será utilizada para criar protocolos de segurança nessa comunicação com o servidor. Serão utilizados padrões SSL/TLS para ser criado um canal criptografado entre o servidor e o sistema alvo, para garantir que todos os dados transmitidos sejam sigilosos e seguros, e também algoritmos de criptografia para o firmware que será enviado por meio dessa conexão.

%essa tarefa estará responsável por criar uma comunicação segura entre o \textit{hardware} e o servidor HTTP, a partir dessa comunicação será feito a verificação do sinal de disponibilidade de novo \textit{software} e \textit{download} do mesmo quando o sistema estiver ocioso. 

\subsection{VERIFICAÇÃO E AGENDAMENTO DE ATUALIZAÇÃO}

O desenvolvedor será responsável em decidir a frequência e/ou horário em que a API irá consultar o servidor para a verificação de uma nova versão de \textit{firmware}, evitando assim que em aplicações onde existam atividades críticas, sejam interrompidas para que a API possa fazer esta verificação, sabendo que a prioridade desta ação deve ser a menor possível na aplicação.

Após a consulta, caso exista uma nova atualização disponível o desenvolvedor pode optar em a executar imediatamente, ou agendar para ser feita em outro horário, em que a aplicação esteja menos ocupada. Esta escolha pode ser programada desde o início do desenvolvimento do \firmware, ou a partir de um sinal durante a consulta por uma nova atualização. Assim caso haja a necessidade da troca de \software imediatamente, esse sinal pode avisar o agendador e já executar todo o processo de substituição de \firmware. 

\subsection{DOWNLOAD E ARMAZENAMENTO DO FIRMWARE}

Quando chegar no tempo desejado pelo agendador, a API iniciará novamente a comunicação com o servidor que contem o \textit{firmware} novo, dessa vez com o propósito de fazer \download da nova versão do \textit{software}. Com o propósito de aumentar a segurança da API o \textit{firmware} que se apresenta após a transferência ainda esta criptografado, assim ele deve passar por uma descriptografia para então ser armazenado no cartão SD. Após essa descriptografia a API ainda irá verificar se o \textit{firmware} recebido pelo servidor esta correto a partir da verificação de hash criptográfica. 

A partir da utilização da biblioteca FatFs, será criado um sistema de arquivo FAT, que gerenciará a memória presente no cartão SD dentro da aplicação, e ele pode ser utilizado tanto pela aplicação final do sistema embarcado, quanto pela API. Esse sistema de arquivo será utilizado para que se possa identificar a posição na memória em que o \textit{firmware} novo será colocado após o seu \download, evitando que outros arquivos pertencentes a aplicação final sejam colocados nesta localização, e fazendo com que o \bootloader interprete de forma errada os arquivos gerando erros.

\section{MATERIAIS UTILIZADOS}

A API será escrita na linguagem C, o bootloader em sua maioria em C também, e alguns trechos em assembly, enquanto o \linker será escrito em comandos de \linker. O sistema de atualização OTA desenvolvido neste trabalho será inicialmente desenvolvido para a plataforma STM32F746G-Discovery.

\subsection{PLATAFORMA STM32F746G-Discovery}

O STM32F7 Discovery é um kit de desenvolvimento que permite ao usuário desenvolver e compartilhar aplicações com toda a série de microcontroladores STM32F7 baseados no processador ARM\textregistered  Cortex\textregistered-M7 core.
O kit discovery permite uma ampla diversidade de aplicações que podem se beneficiar de suporte a múltiplos sensores, áudio, tela gráfica, segurança, vídeos e conexões de alta velocidade \cite{STM32F7}.
A \autoref{STM32F7} ilustra o kit STM32F746NGH6-Discovery.

\begin{figure}[H]
    \scriptsize
     \centering
     \includegraphics[scale=0.4]{dados/figuras/STM32F7.jpg}
     \caption{Kit de desenvolvimento STM32F746G-Discovery. \newline Fonte:\cite{STM32F7}.}
     \label{STM32F7}
\end{figure}

Algumas de suas principais características são:
\begin{itemize}
    \item Microcontrolador STM32F746NGH6 com 1 Mbytes de memória flash e 340 Kbytes de RAM, em um pacote BGA216.
    \item 128-Mbit de memória Quad-SPI Flash.
    \item 128-Mbit SDRAM (Com 64 Mbits Acessível).
    \item Conector para cartão microSD.
    \item Conector Ethernet em conformidade com a IEEE-802.3-2002
    \item Tela LCD de 4.3 polegadas, com resolução de 480x272 com \textit{touch-screen} capacitivo.
    
\end{itemize}